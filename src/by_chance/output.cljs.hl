(ns by-chance.output
  (:require [by-chance.options :as opts]))

;; all lengths here are in seconds
(def TOTAL-PIECE-LENGTH (* 60 8))
(def MIN-MOVEMENT-LENGTH 40)
(def MAX-MOVEMENT-LENGTH 90)

(defn random-movement-lengths
  []
  (loop [lengths []]
    (let [piece-length (apply + lengths)
          remaining    (- TOTAL-PIECE-LENGTH piece-length)
          length       (-> MIN-MOVEMENT-LENGTH
                           (+ (rand-int (- MAX-MOVEMENT-LENGTH
                                           MIN-MOVEMENT-LENGTH)))
                           (min (- TOTAL-PIECE-LENGTH piece-length)))]
      (cond
        (< (+ piece-length length) TOTAL-PIECE-LENGTH)
        (recur (conj lengths length))

        (>= remaining MIN-MOVEMENT-LENGTH)
        (recur (conj lengths remaining))

        :else
        lengths))))

(defn random-piece
  [{:keys [dance]}]
  (let [{:keys [body-parts movement-qualities]} dance
        lengths   (random-movement-lengths)
        ;; There is one movement where, instead of music, there is a special
        ;; backing track consisting of "mystery content".
        mystery-i (rand-nth (range 2 (dec (count lengths))))]
    (if (some #(< (count %) (count lengths))
              [body-parts movement-qualities])
      [::error
       (str "Not enough options. Need " (count lengths) ".")
       {:body-parts      (count body-parts)
        :movement-qualities (count movement-qualities)}]
      [::success
       (map (fn [i body-part dance-quality]
              (merge (if (= mystery-i i)
                       {:length 58 :mystery? true}
                       {:length (nth lengths i)})
                     {:body-part     body-part
                      :dance-quality dance-quality}))
            (range (count lengths))
            (shuffle body-parts)
            (shuffle movement-qualities))])))

(defc piece nil)

(defc= success? (= ::success (first piece)))

(defc refresh-count 0)

(with-timeout 50
  (swap! refresh-count inc))

(do-watch
  (cell= [opts/options refresh-count])
  (fn [_ [options _]]
    (reset! piece (random-piece options))))

(defn min-sec-format
  [seconds]
  (str (quot seconds 60)
       ":"
       (let [s (rem seconds 60)]
         (if (< s 10)
           (str 0 s)
           s))))

(defelem movement-view
  [{:keys [i movement] :as attr} _]
  (cell-let [{:keys [length body-part dance-quality mystery?]}
             movement]
    (p (-> attr
           (dissoc :i :movement)
           (assoc :toggle movement))
       (span :class "font-bold"
             "SECTION " (cell= (inc i)) ": ")
       (span :class "italic"
             (cell= (if (and body-part dance-quality)
                      (str dance-quality ", " body-part)
                      "(stillness)"))))))

(defn performance-view
  [{:keys [i movement] :as attr}]
  (cell-let [{:keys [length body-part dance-quality]} movement]
    (div attr
      (h2 :class "inline-block mr-2"
         "SECTION " (cell= (inc i)))
      (p :class "inline-block italic"
         (cell= (str "(" (min-sec-format length) ")")))
      (p
       (span :class "italic"
             (cell= (if (and body-part dance-quality)
                      (str dance-quality ", " body-part)
                      "(stillness)")))))))

(defelem output-view
  [attr _]
  (let [movements (cell= (second piece))]
    (div attr
         (if-tpl success?
           (div
             (for [i (range 12)
                   :let [movement (cell= (when (< i (count movements))
                                           (nth movements i)))]]
               (when-tpl movement
                 (movement-view
                   {:i        i
                    :movement movement
                    :class    "p-1"}))))
           (div
             (for-tpl [x (cell= (rest piece))]
               (p (cell= (pr-str x)))))))))
